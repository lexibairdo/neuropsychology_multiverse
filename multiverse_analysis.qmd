---
title: "Multiverse Analysis v2.1"
format: docx
---

Dataframes:
mv_complete: has NAs removed

Load all necessary packages and dataframes. For the purposes of this analysis, only Placebo cases will be used.

Specr is the main package used here. Citation post
```{r}
citation("specr")
```
```{r}
#Install and load necessary packages
library(stringr)
library(lavaan)
library(readxl)
library(dplyr)
library(tidyr)
library(lme4)
library(ggplot2)
library(specr)
library(writexl)

#load in the dataframe, mv_complete
mv_complete <- read_excel("mv_complete.xlsx")

#load in multiverse_merged.csv
mv <- read.csv("multiverse_merged.csv")

#filter mv to only include Placebo cases for this analysis
mv <- mv %>% filter(Randomization.StudyTreatmentCat == "Placebo")

#delete any column that has all NA values
mv <- mv[, colSums(is.na(mv)) < nrow(mv)]

```



Merge in the GOSE_GCS appendix, which contains information about TBI severity
```{r}
gose <- read.csv("GOSE_GCS_extended_appendix.csv")
#delete the first row. not needed
gose <- gose[-1,]
#delete scores from the 180 day timepoint
gose <- gose %>% filter(X.8 != "180")
#convert the relevant columns to numeric
gose$PTA <- as.numeric(gose$X.9)
#match GUID column to match other dataframes 
gose$Main.GUID <- gose$X1
#filter gose for only rows where X.8 is "30"
gose <- gose %>% filter(X.8 == "30")
#Reverse Code the PTA variable. Subtract 100 from the PTA scores
table(gose$PTA)
gose$PTA_Reverse <- 100 - gose$PTA       
#Merge the column gose$PTA into mv based on the column mv$Main.GUID
mv <- mv %>%
  left_join(gose %>% select(Main.GUID, PTA_Reverse), by = "Main.GUID")
```

Display sample demographics. Print as a table
```{r}
table(mv$Demographics.GenderTyp)
table(mv$Demographics.RaceCatCOBRIT)
table(mv$Demographics.EthnCatCOBRIT)
table(mv$Demographics.MartlPartnerStatusCOBRIT)
table(mv$Demographics.LivingSituationPreInjTyp)
table(mv$Demographics.EmplymtStatusPreInjTyp)
table(mv$Demographics.AnnualIncomePreInjCat)
```

Clean up the Processing Speed Index data. Display summary stats and histograms. 
```{r}
#Show summary stats for the Processing Speed Index level data
summary(mv$PSIScrCOBRIT)
hist(mv$PSIScrCOBRIT, main = "Processing Speed Index Raw Scores", xlab = "Raw Score", ylab = "Frequency")
#convert to Z scores
mv$PSIScrCOBRIT_Z <- scale(mv$PSIScrCOBRIT, center = TRUE, scale = TRUE)

#Show summary stats for the Processing Speed Index scaled data
summary(mv$PSIDigSymbScldScrCOBRIT)
hist(mv$PSIDigSymbScldScrCOBRIT, main = "Processing Speed Index Scaled Scores", xlab = "Scaled Score", ylab = "Frequency")
#Convert to z scores
mv$PSIDigSymbScldScrCOBRIT_Z <- scale(mv$PSIDigSymbScldScrCOBRIT, center = TRUE, scale = TRUE)

#Show summary stats for Symbol search scaled data
summary(mv$PSISymbSrchScldScrCOBRIT)
hist(mv$PSISymbSrchScldScrCOBRIT, main = "Symbol Search Scaled Scores", xlab = "Scaled Score", ylab = "Frequency")
#convert to z scores
mv$PSISymbSrchScldScrCOBRIT_Z <- scale(mv$PSISymbSrchScldScrCOBRIT, center = TRUE, scale = TRUE)

```

Extract the worst GCS score
```{r}
#show the histogram for the worst GCS score
hist(mv$WorsT.GCS.and.Pupils.GCSTotalScore)
#Show summary stats for the worst GCS score
summary(mv$WorsT.GCS.and.Pupils.GCSTotalScore)
```

Convert all relevant demographic variables to ordinal factors
```{r}
#Convert mv$Demographics.AnnualIncomePreInjCat to an ordinal variable
mv$Demographics.AnnualIncomePreInjOrdinal <- factor(mv$Demographics.AnnualIncomePreInjCat, 
                                                 levels = c("None", "Less than $10,000 per year", "$10,000-$29,999 per year", "$30,000-$49,999 per year", "$50,000-$99,999 per year", "More than $100,000 per year"), 
                                                 ordered = TRUE)

#Convert mv$Demographics.EduLvlUSATypCOBRIT to an ordinal variable
mv$Demographics.EduLvlUSATypCOBRITOrdinal <- factor(mv$Demographics.EduLvlUSATypCOBRIT, 
                                                 levels = c("Some elementary School", "Some high school", "High school graduate/GED", "Some college", "Technical, Vocational, or Trade School", "College graduate", "Some graduate school", "Graduate school completed"), 
                                                 ordered = TRUE)

mv$Demographics.EduLvlUSATypCOBRITOrdinal <- as.integer(mv$Demographics.EduLvlUSATypCOBRITOrdinal)    
mv$Demographics.AnnualIncomePreInjOrdinal <- as.integer(mv$Demographics.AnnualIncomePreInjOrdinal)
```

Generate a new dataframe that only includes complete cases for the variables of interest for this analysis
```{r}
mv_complete <- mv %>%
  select(Main.GUID, Demographics.GenderTyp, PSIScrCOBRIT, PSIScrCOBRIT_Z, .BSI18DeprScoreT, .BSI18AnxScoreT, .BSI18GSIScoreT, PTA_Reverse, PSISymbSrchScldScrCOBRIT, PSISymbSrchScldScrCOBRIT_Z, PSIDigSymbScldScrCOBRIT, PSIDigSymbScldScrCOBRIT_Z, WorsT.GCS.and.Pupils.GCSTotalScore, Main.AgeYrs, Demographics.RaceCatCOBRIT, Demographics.AnnualIncomePreInjOrdinal, Demographics.EduLvlUSATypCOBRITOrdinal, .GOATTotalScore, SWLSTotalScore, DRS.DRSTotalScore, Demographics.AnnualIncomePreInjCat, Demographics.EduLvlUSATypCOBRIT) %>%
  drop_na()

hist(mv_complete$SWLSTotalScore, main = "Satisfaction with Life Scale Total Score", xlab = "Total Score", ylab = "Frequency")
hist(mv_complete$DRS.DRSTotalScore, main = "Disability Rating Scale Total Score", xlab = "Total Score", ylab = "Frequency")
table(mv_complete$DRS.TotalScore)
#Show summary stats for the mv_complete dataframe

#Generate a curvilinear age variable
mv_complete$Main.AgeYrs_Squared <- mv_complete$Main.AgeYrs^2

nrow(mv_complete)

#print all the values in the ID column for mv_complete
mv_complete$Main.GUID

#save all these Main.GUI values to an csv file
write.csv(mv_complete$Main.GUID, "mv_complete_IDs.csv", row.names = FALSE)

```

Standardize the predictor variables. Convert to z-scores
```{r}
#convert the predictors to z-scores
mv_complete$WorsT.GCS.and.Pupils.GCSTotalScore_Z <- scale(mv_complete$WorsT.GCS.and.Pupils.GCSTotalScore, center = TRUE, scale = TRUE)

mv_complete$PTA_Reverse_Z <- scale(mv_complete$PTA_Reverse, center = TRUE, scale = TRUE)

mv_complete$.GOATTotalScore_Z <- scale(mv_complete$.GOATTotalScore, center = TRUE, scale = TRUE)
```

Generate the specification curve for Processing Speed as an outcome. Include three separate predictors and multiple covariates. 
```{r}
# Run specs with custom latent var function
PSI_specs <- specr::setup(data = mv_complete,            
               y = c("PSIScrCOBRIT_Z", "PSISymbSrchScldScrCOBRIT_Z", "PSIDigSymbScldScrCOBRIT_Z"),              
               x = c("WorsT.GCS.and.Pupils.GCSTotalScore_Z", "PTA_Reverse_Z", ".GOATTotalScore_Z"),             
               model = c("lm"), 
               controls = c("Main.AgeYrs", "Main.AgeYrs_Squared", "Demographics.RaceCatCOBRIT", "Demographics.AnnualIncomePreInjOrdinal", "Demographics.EduLvlUSATypCOBRITOrdinal", "Demographics.GenderTyp"))
#generate spec results
PSI_results <- specr(PSI_specs)
#save the results as a dataframe
PSI_results_df <- as.data.frame(PSI_results)
#Generate a plot that only breaks down specification by predictors and outcome variables. Control variables are included in the curve, just remain unlabeled
PSI_outcome_curve <- plot(PSI_results, choices = c("y", "x"))
#Save the plot to working directory
ggsave("PSI_results_curve_y_x_only.jpg")
#generate a boxplot of the same data. 
PSI_outcome_box <- plot(PSI_results, choices = c("y", "x"), 
     type = "boxplot")
#Save the boxplot to working directory
ggsave("PSI_results_boxplot_y_x_only.jpg")
#generate a summary of all the results
PSI_results_summary <- summary(PSI_results, 
        type = "curve", 
        group = c("y", "x"))
#Save the summary as a dataframe
PSI_results_summary_df <- as.data.frame(PSI_results_summary)
#Download as an excel
write_xlsx(PSI_results_summary_df, "PSI_results_summary_df.xlsx")
```

Now, extract the largest and smallest r squared value from all the possible models. Generate a ratio of the two. 
```{r}
#Pull the largest r2 value
largest_r2_value <- max(PSI_results_df$fit_adj.r.squared)
print(largest_r2_value)
smallest_r2_value <- min(PSI_results_df$fit_adj.r.squared)
print(smallest_r2_value)
r2_ratio_PSI <- largest_r2_value / smallest_r2_value
r2_ratio_PSI  

#print the model that corresponds to the largest value
print(PSI_results_df$formula[PSI_results_df$fit_adj.r.squared == largest_r2_value])

#print the model that corresponds to the smallest value
print(PSI_results_df$formula[PSI_results_df$fit_adj.r.squared == smallest_r2_value])
```

Do the same thing but with the beta estimates
```{r}
#extract largest value from latent_model_dataframe$estimate
largest_b_value_PSI <- max(PSI_results_df$estimate)
smallest_b_value_PSI <- min(PSI_results_df$estimate)

b_ratio_PSI <- largest_b_value_PSI / smallest_b_value_PSI
largest_b_value_PSI
smallest_b_value_PSI
b_ratio_PSI

#print the model that corresponds to the largest value
print(PSI_results_df$formula[PSI_results_df$estimate == largest_b_value_PSI])

#print the model that corresponds to the smallest value
print(PSI_results_df$formula[PSI_results_df$estimate == smallest_b_value_PSI])
```

Same thing but with p-values
```{r}
#extract smallest value from latent_model_dataframe$p.value
smallest_p_value_PSI <- min(PSI_results_df$p.value)
largest_p_value_PSI <- max(PSI_results_df$p.value)

#ratio
p_ratio_PSI <- largest_p_value_PSI / smallest_p_value_PSI
p_ratio_PSI

smallest_p_value_PSI
largest_p_value_PSI

#now, make a new column called p.value_sig that is TRUE if the p-value is less than 0.05, and FALSE otherwise
PSI_results_df$p.value_sig <- PSI_results_df$p.value < 0.05
#return a table of the p-value sig column
table(PSI_results_df$p.value_sig)
#generate a count of the ratio of the TRUE to FALSE values
table(PSI_results_df$p.value_sig) |> 
  prop.table() |> 
  round(2) |> 
  print()
```


Generate a function that computes the Cohen's F2 value and updates the dataframe with a column that has these values
```{r}
add_f2 <- function(data, r2_column = "fit_r.squared", plot_name = "f2_plot") {
  if (!r2_column %in% names(data)) {
    stop("Specified R2 column not found in data.")
  }
  
  r2_col <- sym(r2_column)
  
  result <- data |>
    mutate(
      f2_value = !!r2_col / (1 - !!r2_col),
      effect_size = case_when(
        f2_value <= 0.14             ~ "small",
        f2_value > 0.14 & f2_value <= 0.34 ~ "medium",
        f2_value > 0.34              ~ "large"
      )
    )
  
  # Set the order of the effect_size factor
  result$effect_size <- factor(result$effect_size, levels = c("small", "medium", "large"))
  
  # Print summary table
  result |>
    count(effect_size) |>
    print()
  
  # Calculate F² ratio
  f2_max <- max(result$f2_value, na.rm = TRUE)
  f2_min <- min(result$f2_value, na.rm = TRUE)
  f2_ratio <- round(f2_max / f2_min, 2)
  
  # Generate barplot with ratio displayed in the caption
  p <- ggplot(result, aes(x = effect_size, fill = effect_size)) +
    geom_bar() +
    scale_fill_manual(
      name = "Effect Size Category",  # Change legend title here
      values = c(
        "small" = "darkgoldenrod1",
        "medium" = "cyan4",
        "large" = "darksalmon"
      )
    ) +
    labs(
      title = "Counts of Cohen's f² Effect Sizes",
      subtitle = paste("F² max/min ratio =", f2_ratio),
      x = "Effect Size Category",
      y = "Count"
    ) +
    theme_minimal()
  
  # Assign the plot to a variable in the workspace
  assign(plot_name, p, envir = .GlobalEnv)
  
  return(result)
}
```

Apply f2 function to the PSI results dataframe. This will also output a summary table and a barplot of the effect sizes. 
```{r}
PSI_results_df <- add_f2(PSI_results_df, r2_column = "fit_r.squared", plot_name = "PSI_f2_plot")

ggsave("PSI_results_df_f2_barplot.jpg")

#Save results as an excel file
write_xlsx(PSI_results_df, "PSI_results_df.xlsx")
```


Show summary statistics for the Disability Rating Scale. Reverse code it so that higher scores on the DRS reflect less disability.
```{r}
#summary stats and histogram for the DRS
summary(mv_complete$DRS.DRSTotalScore)
hist(mv_complete$DRS.DRSTotalScore, main = "Disability Rating Scale Total Score", xlab = "Total Score", ylab = "Frequency")

#Reverse and scale the DRS scores so that higher scores reflect less disability, rather than more disability
mv_complete$DRS_Scaled <- 30 - mv_complete$DRS.DRSTotalScore

#Convert all three variables to z-scores
mv_complete$SWLSTotalScore_Z <- scale(mv_complete$SWLSTotalScore, center = TRUE, scale = TRUE)
mv_complete$DRS_Scaled_Z <- scale(mv_complete$DRS_Scaled, center = TRUE, scale = TRUE)

#Generate a composite variable with the satisfaction with life scale
mv_complete$SWLS_DRS_Composite_Z <- (mv_complete$SWLSTotalScore_Z + mv_complete$DRS_Scaled_Z) / 2

```

Generate the specification curve for the Disability Rating Scale, Satisfaction with Life Score and the composite variable combining the two
```{r}
# Run specs with outcome variables measuring quality of life
qol_specs <- specr::setup(data = mv_complete,            
               y = c("SWLSTotalScore_Z", "DRS_Scaled_Z", "SWLS_DRS_Composite_Z"),              
               x = c("WorsT.GCS.and.Pupils.GCSTotalScore_Z", "PTA_Reverse_Z", ".GOATTotalScore_Z"),             
               model = c("lm"), 
               controls = c("Main.AgeYrs", "Main.AgeYrs_Squared", "Demographics.RaceCatCOBRIT", "Demographics.AnnualIncomePreInjOrdinal", "Demographics.EduLvlUSATypCOBRITOrdinal", "Demographics.GenderTyp"))

#generate results
qol_specs_results <- specr(qol_specs)
#Save the results as a dataframe
qol_specs_results_df <- as.data.frame(qol_specs_results)
#Plot the specification curve
qol_outcome_curve <- plot(qol_specs_results, 
      choices = c("y", "x"))
qol_outcome_curve
#Save the plot 
ggsave("qol_specs_results_curve_y_x.jpg")
#Plot the same data as a boxplot
qol_outcome_box <- plot(qol_specs_results, 
      choices = c("y", "x"), 
      type = "boxplot")
#Save the boxplot
ggsave("qol_specs_results_boxplot_y_x.jpg")
#Generate the summary of the results
qol_specs_results_summary <- summary(qol_specs_results, 
        type = "curve", 
        group = c("y", "x"))
#save the summary results and full results as a dataframe. Download as excel
qol_specs_results_df <- as.data.frame(qol_specs_results)
write_xlsx(qol_specs_results_df, "qol_specs_results_df.xlsx")
qol_specs_results_summary_df <- as.data.frame(qol_specs_results_summary)
write_xlsx(qol_specs_results_summary_df, "qol_specs_results_summary_df.xlsx")
```

Extract the largest and smallest r squared value from all the possible models for QOL measures. Generate a ratio of the two.
```{r}
#extract largest and smallest value from qol_specs_results_df$fit_adj.r.squared
largest_r2_value <- max(qol_specs_results_df$fit_adj.r.squared)
smallest_r2_value <- min(qol_specs_results_df$fit_adj.r.squared)

largest_r2_value
smallest_r2_value

r2_ratio_QOL <- largest_r2_value / smallest_r2_value
r2_ratio_QOL
```

same thing but with p values
```{r}
#extract smallest value from latent_model_dataframe$p.value
smallest_p_value_QOL <- min(qol_specs_results_df$p.value)
largest_p_value_QOL <- max(qol_specs_results_df$p.value)

#ratio
p_ratio_QOL <- largest_p_value_QOL / smallest_p_value_QOL
p_ratio_QOL

smallest_p_value_QOL
largest_p_value_QOL

#now, make a new column called p.value_sig that is TRUE if the p-value is less than 0.05, and FALSE otherwise
qol_specs_results_df$p.value_sig <- qol_specs_results_df$p.value < 0.05
#return a table of the p-value sig column
table(qol_specs_results_df$p.value_sig)
#generate a count of the ratio of the TRUE to FALSE values
table(qol_specs_results_df$p.value_sig) |> 
  prop.table() |> 
  round(2) |> 
  print()
```

Generate the F2 values for the QOL measures
```{r}
#Apply the add_f2 function to the qol_specs_results_df
qol_specs_results_df <- add_f2(qol_specs_results_df, r2_column = "fit_r.squared", plot_name = "QOL_f2_plot")
ggsave("qol_specs_results_df_f2_barplot.jpg")
#save as excel
write_xlsx(qol_specs_results_df, "qol_specs_results_df.xlsx")
```

Now for mood measures. Show the distribution of scores for the BSI Depression, Anxiety and general symptom scores
```{r}
#BSI Depression subscale
summary(mv_complete$.BSI18DeprScoreT)
hist(mv_complete$.BSI18DeprScoreT, main = "BSI Depression Subscale", xlab = "T Score", ylab = "Frequency")
#z score
mv_complete$.BSI18DeprScoreT_Z <- scale(mv_complete$.BSI18DeprScoreT, center = TRUE, scale = TRUE)
#BSI Anxiety subscale
summary(mv_complete$.BSI18AnxScoreT)
hist(mv_complete$.BSI18AnxScoreT, main = "BSI Anxiety Subscale", xlab = "T Score", ylab = "Frequency")
#z score
mv_complete$.BSI18AnxScoreT_Z <- scale(mv_complete$.BSI18AnxScoreT, center = TRUE, scale = TRUE)
#BSI General Symptom Index
summary(mv_complete$.BSI18GSIScoreT)
hist(mv_complete$.BSI18GSIScoreT, main = "BSI General Symptom Index", xlab = "T Score", ylab = "Frequency")
#z score
mv_complete$.BSI18GSIScoreT_Z <- scale(mv_complete$.BSI18GSIScoreT, center = TRUE, scale = TRUE)
```

Generate the specification curve for the BSI Depression, Anxiety and General Symptom Index scores
```{r}
#Generate the specification curve for the mood related outcome variables
mood_outcome_specs <- specr::setup(data = mv_complete,            
               y = c(".BSI18GSIScoreT_Z", ".BSI18DeprScoreT_Z", ".BSI18AnxScoreT_Z"),              
               x = c("WorsT.GCS.and.Pupils.GCSTotalScore_Z", "PTA_Reverse_Z", ".GOATTotalScore_Z"),             
               model = c("lm"), 
               controls = c("Main.AgeYrs", "Main.AgeYrs_Squared", "Demographics.RaceCatCOBRIT", "Demographics.AnnualIncomePreInjOrdinal", "Demographics.EduLvlUSATypCOBRITOrdinal", "Demographics.GenderTyp"))

mood_outcome_results <- specr(mood_outcome_specs)
#Save the results as a df
mood_outcome_results_df <- as.data.frame(mood_outcome_results)
#Generate a plot
mood_outcome_curve <- plot(mood_outcome_results, 
      choices = c("y", "x"))
#Save the plot
ggsave("mood_outcome_results_curve_y_x.jpg")
#Generate a boxplot
mood_outcome_box <- plot(mood_outcome_results, 
      choices = c("y", "x"), 
      type = "boxplot")
#Save the boxplot
ggsave("mood_outcome_results_boxplot_y_x.jpg")
#Generate a summary of the results
mood_outcome_results_summary <- summary(mood_outcome_results, 
        type = "curve", 
        group = c("y", "x"))
#Save the summary results and full results as a dataframe. Download as excel
mood_outcome_results_df <- as.data.frame(mood_outcome_results)
write_xlsx(mood_outcome_results_df, "mood_outcome_results_df.xlsx")
```

#Generate the F2 values for the mood measures
```{r}
#apply the add_f2 function to the mood_outcome_results_df
mood_outcome_results_df <- add_f2(mood_outcome_results_df, r2_column = "fit_r.squared", plot_name = "Mood_f2_plot")
ggsave("mood_outcome_results_df_f2_barplot.jpg")
```

p-values 
```{r}
#extract smallest value from latent_model_dataframe$p.value
smallest_p_value_mood <- min(mood_outcome_results_df$p.value)
largest_p_value_mood <- max(mood_outcome_results_df$p.value)

#ratio
p_ratio_mood <- largest_p_value_mood / smallest_p_value_mood
p_ratio_mood

smallest_p_value_mood
largest_p_value_mood

#now, make a new column called p.value_sig that is TRUE if the p-value is less than 0.05, and FALSE otherwise
mood_outcome_results_df$p.value_sig <- mood_outcome_results_df$p.value < 0.05
#return a table of the p-value sig column
table(mood_outcome_results_df$p.value_sig)
#generate a count of the ratio of the TRUE to FALSE values
table(mood_outcome_results_df$p.value_sig) |> 
  prop.table() |> 
  round(2) |> 
  print()
```

